library IEEE;
use IEEE.std_logic_1164.all;

entity DE2_115 is
	port(	CLOCK_50 : in std_logic;
			KEY : in std_logic_vector(0 downto 0);
			GPIO : inout std_logic_vector(5 downto 0);
			LEDR : out std_logic_vector(15 downto 0);
			LEDG : out std_logic_vector(0 downto 0)
		 );
end entity; 

architecture structural of DE2_115 is

	component i2c_master IS
	  GENERIC(
		 input_clk : INTEGER := 50_000_000; --input clock speed from user logic in Hz
		 bus_clk   : INTEGER := 400_000);   --speed the i2c bus (scl) will run at in Hz
	  PORT(
		 clk       : IN     STD_LOGIC;                    --system clock
		 reset_n   : IN     STD_LOGIC;                    --active low reset
		 ena       : IN     STD_LOGIC;                    --latch in command
		 addr      : IN     STD_LOGIC_VECTOR(6 DOWNTO 0); --address of target slave
		 rw        : IN     STD_LOGIC;                    --'0' is write, '1' is read
		 data_wr   : IN     STD_LOGIC_VECTOR(7 DOWNTO 0); --data to write to slave
		 busy      : OUT    STD_LOGIC;                    --indicates transaction in progress
		 data_rd   : OUT    STD_LOGIC_VECTOR(7 DOWNTO 0); --data read from slave
		 ack_error : BUFFER STD_LOGIC;                    --flag if improper acknowledge from slave
		 sda       : INOUT  STD_LOGIC;                    --serial data output of i2c bus
		 scl       : INOUT  STD_LOGIC);                   --serial clock output of i2c bus
	END component;
	
	component i2c_controller IS
	  PORT(
		 clk       : IN     STD_LOGIC;                    		--system clock
		 reset_n   : IN     STD_LOGIC;                    		--active low reset
		 ena       : OUT     STD_LOGIC;                    	--latch in command
		 addr      : OUT     STD_LOGIC_VECTOR(6 DOWNTO 0); 	--address of target slave
		 rw        : OUT     STD_LOGIC;                    	--'0' is write, '1' is read
		 data_wr   : OUT     STD_LOGIC_VECTOR(7 DOWNTO 0); 	--data to write to slave
		 busy      : IN    STD_LOGIC;                    		--indicates transaction in progress
		 data_rd   : IN    STD_LOGIC_VECTOR(7 DOWNTO 0); 		--data read from slave
		 data_sample : out std_logic_vector(15 downto 0);
		 to1, to2 : out std_logic
		 );
	END component;

	
	signal i2c_ena : std_logic;
	signal i2c_addr : std_logic_vector(6 downto 0);
	signal i2c_rw : std_logic;
	signal i2c_data_wr : std_logic_vector(7 downto 0);
	signal i2c_busy : std_logic;
	signal i2c_data_rd : std_logic_vector(7 downto 0);
	
	signal to1, to2 : std_logic;
	
begin

	i2c : i2c_master port map (clk => CLOCK_50, 
										reset_n => KEY(0), 
										ena => i2c_ena, 
										addr => i2c_addr, 
										rw => i2c_rw, 
										data_wr => i2c_data_wr, 
										busy => i2c_busy, 
										data_rd => i2c_data_rd, 
										sda => GPIO(0), 
										scl => GPIO(1),
										ack_error => LEDG(0)
										);
										
	controller : i2c_controller port map (	clk => CLOCK_50,
														reset_n => KEY(0),
														ena => i2c_ena, 
														addr => i2c_addr, 
														rw => i2c_rw, 
														data_wr => i2c_data_wr,
														busy => i2c_busy,
														data_rd => i2c_data_rd,
														data_sample => LEDR,
														to1 => to1,
														to2 => to2
														);

	GPIO(2) <= i2c_busy;
	GPIO(3) <= i2c_ena;
	GPIO(4) <= to1;
	GPIO(5) <= to2;

end architecture;	