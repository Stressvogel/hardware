--library IEEE;
--use IEEE.std_logic_1164.all;
--use IEEE.numeric_std.all;
--
--entity synchronizer is
--	port (clk, reset_n : in std_logic;
--			sig_1i, sig_2i : in std_logic_vector(15 downto 0);
--			sig_1o, sig_2o : out std_logic_vector(15 downto 0)
--		   );
--end entity;

architecture behavioural of synchronizer is
begin
	process(clk, reset_n)
		variable next_index : integer range 0 to 1602;
		variable sig_1_buffer : std_logic_vector(16*1602-1 downto 0);
		variable counter : integer range 0 to 430;
	begin
		if reset_n = '0' then
			next_index := 0;
			counter := 0;
			sig_1_buffer := (others => '0');
		elsif rising_edge(clk) then
			if unsigned(sig_1i) /= 0 and counter >= 430 then
				sig_1_buffer(next_index*16+15 downto next_index*16) := sig_1i;
				-- else should reset
				if next_index < 1603 then
					next_index := next_index + 1;
				end if;
			else counter := counter + 1; -- discard sig_1i
			end if;
			
			if unsigned(sig_2i) /= 0 then
				sig_1o <= sig_1_buffer(15 downto 0);
				sig_2o <= sig_2i;
				sig_1_buffer := "0000000000000000" & sig_1_buffer(sig_1_buffer'LEFT downto 16);
				if next_index > 0 then
					next_index := next_index - 1;
				end if;
			end if;
		end if;
	end process;
end architecture; 